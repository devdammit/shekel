package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"fmt"

	"github.com/devdammit/shekel/cmd/unit/internal/entities"
	"github.com/devdammit/shekel/cmd/unit/internal/handlers/graphql/model"
	port "github.com/devdammit/shekel/cmd/unit/internal/ports/use-cases"
	"github.com/devdammit/shekel/pkg/currency"
	"github.com/devdammit/shekel/pkg/gql"
	"github.com/devdammit/shekel/pkg/types/datetime"
)

// Initialize is the resolver for the initialize field.
func (r *mutationResolver) Initialize(ctx context.Context, startDate gql.Date) (bool, error) {
	err := r.UseCases.Initialize.Execute(ctx, datetime.NewDate(startDate.Time))
	if err != nil {
		return false, err
	}

	return true, nil
}

// AddAccount is the resolver for the addAccount field.
func (r *mutationResolver) AddAccount(ctx context.Context, account model.CreateAccountInput) (bool, error) {
	var contactType entities.AccountType

	switch account.Type {
	case model.AccountTypeCash:
		contactType = entities.AccountTypeCash
	case model.AccountTypeCredit:
		contactType = entities.AccountTypeCredit
	case model.AccountTypeDebit:
		contactType = entities.AccountTypeDebit
	default:
		return false, fmt.Errorf("invalid account type: %s", account.Type)
	}

	ok, err := r.UseCases.CreateAccount.Execute(ctx, port.CreateAccountParams{
		Name:        account.Name,
		Description: account.Description,
		Type:        contactType,
		Balance: currency.Amount{
			Value:        account.Balance.Amount,
			CurrencyCode: account.Balance.Currency.Code,
		},
	})
	if err != nil {
		return false, err
	}

	return ok, nil
}

// AddContact is the resolver for the addContact field.
func (r *mutationResolver) AddContact(ctx context.Context, contact model.AddContactInput, qrCode *model.QRCodeInput) (bool, error) {
	req := port.CreateContactRequest{
		Name: contact.Name,
		Text: contact.Text,
	}

	if qrCode != nil {
		req.QRCodes = append(req.QRCodes, port.ContactQRCode{
			BankName: qrCode.Bank,
			Image: port.ContactImage{
				Content:     qrCode.File.File,
				Name:        qrCode.File.Filename,
				Size:        qrCode.File.Size,
				ContentType: qrCode.File.ContentType,
			},
		})
	}

	err := r.UseCases.CreateContact.Execute(ctx, req)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateContact is the resolver for the updateContact field.
func (r *mutationResolver) UpdateContact(ctx context.Context, name string, text string) (bool, error) {
	err := r.UseCases.UpdateContact.Execute(ctx, port.UpdateContactRequest{
		Name: name,
		Text: text,
	})
	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveContact is the resolver for the removeContact field.
func (r *mutationResolver) RemoveContact(ctx context.Context, contactID uint64) (bool, error) {
	err := r.UseCases.DeleteContact.Execute(ctx, contactID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// SetQRCodeToContact is the resolver for the setQRCodeToContact field.
func (r *mutationResolver) SetQRCodeToContact(ctx context.Context, contactID uint64, qrCode model.QRCodeInput) (bool, error) {
	err := r.UseCases.SetQRCodeToContact.Execute(ctx, contactID, port.ContactQRCode{
		BankName: qrCode.Bank,
		Image: port.ContactImage{
			Content:     qrCode.File.File,
			Name:        qrCode.File.Filename,
			Size:        qrCode.File.Size,
			ContentType: qrCode.File.ContentType,
		},
	})

	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveQRCodeFromContact is the resolver for the removeQRCodeFromContact field.
func (r *mutationResolver) RemoveQRCodeFromContact(ctx context.Context, contactID uint64, bankName string) (bool, error) {
	err := r.UseCases.RemoveQRCodeFromContact.Execute(ctx, contactID, bankName)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Contacts is the resolver for the contacts field.
func (r *queryResolver) Contacts(ctx context.Context, withDeleted *bool) ([]entities.Contact, error) {
	return r.Reader.Contacts.GetAll(ctx, withDeleted)
}

// App is the resolver for the app field.
func (r *queryResolver) App(ctx context.Context) (model.App, error) {
	app, err := r.Reader.App.GetInfo(ctx)

	if err != nil {
		return model.App{}, err
	}

	return model.App{
		Initialized:  app.Initialized,
		Version:      app.Version,
		ActivePeriod: app.ActivePeriod,
	}, nil
}

// Periods is the resolver for the periods field.
func (r *queryResolver) Periods(ctx context.Context, limit *uint64, offset *uint64) ([]entities.Period, error) {
	return r.Reader.Periods.GetAll(ctx, limit, offset)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
