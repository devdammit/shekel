package graphql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.43

import (
	"context"
	"fmt"
	"time"

	"github.com/devdammit/shekel/cmd/unit/internal/entities"
	"github.com/devdammit/shekel/cmd/unit/internal/handlers/graphql/model"
	repoport "github.com/devdammit/shekel/cmd/unit/internal/ports/repositories"
	port "github.com/devdammit/shekel/cmd/unit/internal/ports/use-cases"
	"github.com/devdammit/shekel/pkg/currency"
	"github.com/devdammit/shekel/pkg/gql"
	"github.com/devdammit/shekel/pkg/planner"
	"github.com/devdammit/shekel/pkg/pointer"
	"github.com/devdammit/shekel/pkg/types/datetime"
)

// Initialize is the resolver for the initialize field.
func (r *mutationResolver) Initialize(ctx context.Context, startDate gql.Date) (bool, error) {
	err := r.UseCases.Initialize.Execute(ctx, datetime.NewDate(startDate.Time))
	if err != nil {
		return false, err
	}

	return true, nil
}

// AddInvoice is the resolver for the addInvoice field.
func (r *mutationResolver) AddInvoice(ctx context.Context, invoice model.CreateInvoiceInput) (bool, error) {
	var interval *entities.RepeatPlanner

	if invoice.Plan != nil {
		interval = &entities.RepeatPlanner{
			IntervalCount: invoice.Plan.IntervalCount,
			EndCount:      invoice.Plan.EndCount,
			Interval:      planner.PlanRepeatInterval(invoice.Plan.Interval),
		}

		if invoice.Plan.DaysOfWeek != nil {
			interval.DaysOfWeek = make([]time.Weekday, len(invoice.Plan.DaysOfWeek))

			for i, day := range invoice.Plan.DaysOfWeek {
				interval.DaysOfWeek[i] = time.Weekday(day)
			}
		}

		if invoice.Plan.EndDate != nil {
			interval.EndDate = pointer.Ptr(datetime.NewDate(invoice.Plan.EndDate.Time))
		}

	}

	err := r.UseCases.CreateInvoice.Execute(ctx, port.CreateInvoiceRequest{
		Name:        invoice.Name,
		Description: invoice.Description,
		Plan:        interval,
		Type:        entities.InvoiceType(invoice.Type),
		ContactID:   invoice.ContactID,
		Amount: currency.Amount{
			Value:        invoice.Amount.Amount,
			CurrencyCode: invoice.Amount.Currency.Code,
		},
		Date: datetime.NewDateTime(invoice.Date.Time),
	})

	if err != nil {
		return false, err
	}

	return true, nil
}

// AddAccount is the resolver for the addAccount field.
func (r *mutationResolver) AddAccount(ctx context.Context, account model.CreateAccountInput) (bool, error) {
	var contactType entities.AccountType

	switch account.Type {
	case model.AccountTypeCash:
		contactType = entities.AccountTypeCash
	case model.AccountTypeCredit:
		contactType = entities.AccountTypeCredit
	case model.AccountTypeDebit:
		contactType = entities.AccountTypeDebit
	default:
		return false, fmt.Errorf("invalid account type: %s", account.Type)
	}

	ok, err := r.UseCases.CreateAccount.Execute(ctx, port.CreateAccountParams{
		Name:        account.Name,
		Description: account.Description,
		Type:        contactType,
		Balance: currency.Amount{
			Value:        account.Balance.Amount,
			CurrencyCode: account.Balance.Currency.Code,
		},
	})
	if err != nil {
		return false, err
	}

	return ok, nil
}

// AddContact is the resolver for the addContact field.
func (r *mutationResolver) AddContact(ctx context.Context, contact model.AddContactInput, qrCode *model.QRCodeInput) (bool, error) {
	req := port.CreateContactRequest{
		Name: contact.Name,
		Text: contact.Text,
	}

	if qrCode != nil {
		req.QRCodes = append(req.QRCodes, port.ContactQRCode{
			BankName: qrCode.Bank,
			Image: port.ContactImage{
				Content:     qrCode.File.File,
				Name:        qrCode.File.Filename,
				Size:        qrCode.File.Size,
				ContentType: qrCode.File.ContentType,
			},
		})
	}

	err := r.UseCases.CreateContact.Execute(ctx, req)
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateContact is the resolver for the updateContact field.
func (r *mutationResolver) UpdateContact(ctx context.Context, name string, text string) (bool, error) {
	err := r.UseCases.UpdateContact.Execute(ctx, port.UpdateContactRequest{
		Name: name,
		Text: text,
	})
	if err != nil {
		return false, err
	}

	return true, nil
}

// UpdateAccount is the resolver for the updateAccount field.
func (r *mutationResolver) UpdateAccount(ctx context.Context, account model.UpdateAccountInput) (bool, error) {
	ok, err := r.UseCases.UpdateAccount.Execute(ctx, account.ID, account.Name, account.Description, currency.Amount{
		Value:        account.Balance.Amount,
		CurrencyCode: account.Balance.Currency.Code,
	})
	if err != nil {
		return false, err
	}

	return ok, nil
}

// UpdateInvoice is the resolver for the updateInvoice field.
func (r *mutationResolver) UpdateInvoice(ctx context.Context, invoice model.UpdateInvoiceInput) (bool, error) {
	var interval *entities.RepeatPlanner

	if invoice.Plan != nil {
		interval = &entities.RepeatPlanner{
			IntervalCount: invoice.Plan.IntervalCount,
			EndCount:      invoice.Plan.EndCount,
			Interval:      planner.PlanRepeatInterval(invoice.Plan.Interval),
		}

		if invoice.Plan.DaysOfWeek != nil {
			interval.DaysOfWeek = make([]time.Weekday, len(invoice.Plan.DaysOfWeek))

			for i, day := range invoice.Plan.DaysOfWeek {
				interval.DaysOfWeek[i] = time.Weekday(day)
			}
		}

		if invoice.Plan.EndDate != nil {
			interval.EndDate = pointer.Ptr(datetime.NewDate(invoice.Plan.EndDate.Time))
		}

	}

	err := r.UseCases.UpdateInvoice.Execute(ctx, port.UpdateInvoiceRequest{
		InvoiceID:   invoice.ID,
		Name:        invoice.Name,
		Description: invoice.Description,
		Plan:        interval,
		Type:        entities.InvoiceType(invoice.Type),
		ContactID:   invoice.ContactID,
		Amount: currency.Amount{
			Value:        invoice.Amount.Amount,
			CurrencyCode: invoice.Amount.Currency.Code,
		},
		Date: datetime.NewDateTime(invoice.Date.Time),
	})

	if err != nil {
		return false, err
	}

	return true, nil
}

// DeleteAccount is the resolver for the deleteAccount field.
func (r *mutationResolver) DeleteAccount(ctx context.Context, id uint64) (bool, error) {
	return r.UseCases.DeleteAccount.Execute(ctx, id)
}

// RemoveContact is the resolver for the removeContact field.
func (r *mutationResolver) RemoveContact(ctx context.Context, contactID uint64) (bool, error) {
	err := r.UseCases.DeleteContact.Execute(ctx, contactID)
	if err != nil {
		return false, err
	}

	return true, nil
}

// SetQRCodeToContact is the resolver for the setQRCodeToContact field.
func (r *mutationResolver) SetQRCodeToContact(ctx context.Context, contactID uint64, qrCode model.QRCodeInput) (bool, error) {
	err := r.UseCases.SetQRCodeToContact.Execute(ctx, contactID, port.ContactQRCode{
		BankName: qrCode.Bank,
		Image: port.ContactImage{
			Content:     qrCode.File.File,
			Name:        qrCode.File.Filename,
			Size:        qrCode.File.Size,
			ContentType: qrCode.File.ContentType,
		},
	})

	if err != nil {
		return false, err
	}

	return true, nil
}

// RemoveQRCodeFromContact is the resolver for the removeQRCodeFromContact field.
func (r *mutationResolver) RemoveQRCodeFromContact(ctx context.Context, contactID uint64, bankName string) (bool, error) {
	err := r.UseCases.RemoveQRCodeFromContact.Execute(ctx, contactID, bankName)
	if err != nil {
		return false, err
	}

	return true, nil
}

// App is the resolver for the app field.
func (r *queryResolver) App(ctx context.Context) (model.App, error) {
	app, err := r.Reader.App.GetInfo(ctx)

	if err != nil {
		return model.App{}, err
	}

	return model.App{
		Initialized:  app.Initialized,
		Version:      app.Version,
		ActivePeriod: app.ActivePeriod,
	}, nil
}

// Accounts is the resolver for the accounts field.
func (r *queryResolver) Accounts(ctx context.Context, withDeleted *bool) ([]entities.Account, error) {
	return r.Reader.Accounts.GetAll(ctx, withDeleted)
}

// Contacts is the resolver for the contacts field.
func (r *queryResolver) Contacts(ctx context.Context, withDeleted *bool) ([]entities.Contact, error) {
	return r.Reader.Contacts.GetAll(ctx, withDeleted)
}

// InvoicesByPeriod is the resolver for the invoicesByPeriod field.
func (r *queryResolver) InvoicesByPeriod(ctx context.Context, params model.FindInvoiceByPeriod) ([]entities.Invoice, error) {
	var req repoport.FindByDatesRequest

	period, err := r.Reader.Periods.GetByID(ctx, params.PeriodID)
	if err != nil {
		return nil, err
	}

	if period.ClosedAt == nil {
		estimatedEndDate, err := r.Services.Periods.GetEstimatedEndDate(ctx)
		if err != nil {
			return nil, err
		}

		req.EndedAt = estimatedEndDate
	} else {
		req.EndedAt = *period.ClosedAt
	}

	if params.OrderBy != nil {
		switch *params.OrderBy {
		case model.InvoicesOrderByDateDesc:
			req.OrderBy = pointer.Ptr(repoport.OrderByDateDesc)
		case model.InvoicesOrderByDateAsc:
			req.OrderBy = pointer.Ptr(repoport.OrderByDateAsc)
		}
	}

	req.Limit = params.Limit
	req.Offset = params.Offset

	return r.Reader.Invoices.FindByDates(ctx, req)
}

// Periods is the resolver for the periods field.
func (r *queryResolver) Periods(ctx context.Context, limit *uint64, offset *uint64) ([]entities.Period, error) {
	return r.Reader.Periods.GetAll(ctx, limit, offset)
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
